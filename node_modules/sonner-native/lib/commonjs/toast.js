"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToastIcon = exports.Toast = void 0;
var _icons = require("./icons.js");
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeReanimated = _interopRequireDefault(require("react-native-reanimated"));
var _animations = require("./animations.js");
var _constants = require("./constants.js");
var _context = require("./context.js");
var _gestures = require("./gestures.js");
var _types = require("./types.js");
var _useAppState = require("./use-app-state.js");
var _useColors = require("./use-colors.js");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const Toast = ({
  id,
  title,
  jsx,
  description,
  icon,
  duration: durationProps,
  variant,
  action,
  cancel,
  onDismiss,
  onAutoClose,
  dismissible = _constants.toastDefaultValues.dismissible,
  closeButton: closeButtonProps,
  actionButtonStyle,
  actionButtonTextStyle,
  actionButtonClassName,
  actionButtonTextClassName,
  cancelButtonStyle,
  cancelButtonTextStyle,
  cancelButtonClassName,
  cancelButtonTextClassName,
  style,
  className,
  classNames,
  styles,
  promiseOptions,
  position,
  unstyled: unstyledProps,
  important
}) => {
  const {
    duration: durationCtx,
    addToast,
    closeButton: closeButtonCtx,
    unstyled: unstyledCtx,
    styles: stylesCtx,
    classNames: classNamesCtx,
    icons,
    pauseWhenPageIsHidden,
    cn
  } = (0, _context.useToastContext)();
  const unstyled = unstyledProps ?? unstyledCtx;
  const duration = durationProps ?? durationCtx;
  const closeButton = closeButtonProps ?? closeButtonCtx;
  const colors = (0, _useColors.useColors)();
  const {
    entering,
    exiting
  } = (0, _animations.useToastLayoutAnimations)(position);
  const isDragging = React.useRef(false);
  const timer = React.useRef();
  const timerStart = React.useRef();
  const timeLeftOnceBackgrounded = React.useRef();
  const isResolvingPromise = React.useRef(false);
  const onBackground = React.useCallback(() => {
    if (!pauseWhenPageIsHidden) {
      return;
    }
    if (timer.current) {
      timeLeftOnceBackgrounded.current = duration - (Date.now() - timerStart.current);
      clearTimeout(timer.current);
      timer.current = undefined;
      timerStart.current = undefined;
    }
  }, [duration, pauseWhenPageIsHidden]);
  const onForeground = React.useCallback(() => {
    if (!pauseWhenPageIsHidden) {
      return;
    }
    if (timeLeftOnceBackgrounded.current && timeLeftOnceBackgrounded.current > 0) {
      timer.current = setTimeout(() => {
        if (!isDragging.current) {
          onAutoClose?.(id);
        }
      }, Math.max(timeLeftOnceBackgrounded.current, 1000) // minimum 1 second to avoid weird behavior
      );
    } else {
      onAutoClose?.(id);
    }
  }, [id, onAutoClose, pauseWhenPageIsHidden]);
  (0, _useAppState.useAppStateListener)(React.useMemo(() => ({
    onBackground,
    onForeground
  }), [onBackground, onForeground]));
  React.useEffect(() => {
    if (isResolvingPromise.current) {
      return;
    }
    if (promiseOptions?.promise) {
      try {
        isResolvingPromise.current = true;
        promiseOptions.promise.then(data => {
          addToast({
            title: promiseOptions.success(data) ?? 'Success',
            id,
            variant: 'success',
            promiseOptions: undefined
          });
          isResolvingPromise.current = false;
        });
      } catch (error) {
        addToast({
          title: promiseOptions.error ?? 'Error',
          id,
          variant: 'error',
          promiseOptions: undefined
        });
        isResolvingPromise.current = false;
      }
      return;
    }
    if (duration === Infinity) {
      return;
    }

    // Start the timer only if it hasn't been started yet
    if (!timerStart.current) {
      timerStart.current = Date.now();
      timer.current = setTimeout(() => {
        if (!isDragging.current) {
          onAutoClose?.(id);
        }
      }, _animations.ANIMATION_DURATION + duration);
    }

    // Cleanup function to clear the timer if it's still the same timer
    return () => {
      if (timer.current) {
        clearTimeout(timer.current);
        timer.current = undefined;
        timerStart.current = undefined;
      }
    };
  }, [duration, id, onDismiss, promiseOptions, addToast, onAutoClose]);
  if (jsx) {
    return jsx;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_gestures.ToastSwipeHandler, {
    onRemove: () => {
      onDismiss?.(id);
    },
    onBegin: () => {
      isDragging.current = true;
    },
    onFinalize: () => {
      isDragging.current = false;
      const timeElapsed = Date.now() - timerStart.current;
      if (timeElapsed < duration) {
        timer.current = setTimeout(() => {
          onDismiss?.(id);
        }, duration - timeElapsed);
      } else {
        onDismiss?.(id);
      }
    },
    enabled: !promiseOptions && dismissible,
    style: [stylesCtx.toastContainer, styles?.toastContainer],
    className: cn(classNamesCtx.toastContainer, classNames?.toastContainer),
    unstyled: unstyled,
    important: important,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
      className: cn(className, classNamesCtx.toast, classNames?.toast),
      style: [unstyled ? undefined : elevationStyle, stylesCtx.toast, styles?.toast, style, unstyled ? undefined : {
        justifyContent: 'center',
        padding: 16,
        borderRadius: 16,
        marginHorizontal: 16,
        backgroundColor: colors['background-primary'],
        borderCurve: 'continuous'
      }],
      entering: entering,
      exiting: exiting,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
        style: [unstyled ? undefined : {
          flexDirection: 'row',
          gap: 16,
          alignItems: description?.length === 0 ? 'center' : undefined
        }, stylesCtx.toastContent, styles?.toastContent],
        className: cn(classNamesCtx.toastContent, classNames?.toastContent),
        children: [promiseOptions || variant === 'loading' ? 'loading' in icons ? icons.loading : /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.ActivityIndicator, {}) : icon || variant in icons ? icons[variant] : /*#__PURE__*/(0, _jsxRuntime.jsx)(ToastIcon, {
          variant: variant
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
          style: {
            flex: 1
          },
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
            style: [unstyled ? undefined : {
              fontWeight: '600',
              lineHeight: 20,
              color: colors['text-primary']
            }, stylesCtx.title, styles?.title],
            className: cn(classNamesCtx.title, classNames?.title),
            children: title
          }), description ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
            style: [unstyled ? undefined : {
              fontSize: 14,
              lineHeight: 20,
              marginTop: 2,
              color: colors['text-tertiary']
            }, stylesCtx.description, styles?.description],
            className: cn(classNamesCtx.description, classNames?.description),
            children: description
          }) : null, /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
            style: [unstyled || !action && !cancel ? undefined : {
              flexDirection: 'row',
              alignItems: 'center',
              gap: 16,
              marginTop: 16
            }, stylesCtx.buttons, styles?.buttons],
            className: cn(classNamesCtx.buttons, classNames?.buttons),
            children: [(0, _types.isToastAction)(action) ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Pressable, {
              onPress: action.onClick,
              className: actionButtonClassName,
              style: [unstyled ? undefined : {
                flexGrow: 0,
                alignSelf: 'flex-start',
                borderRadius: 999,
                borderWidth: 1,
                borderColor: colors['border-secondary'],
                paddingHorizontal: 8,
                paddingVertical: 4,
                borderCurve: 'continuous',
                backgroundColor: colors['background-secondary']
              }, actionButtonStyle],
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
                numberOfLines: 1,
                style: [unstyled ? undefined : {
                  fontSize: 14,
                  lineHeight: 20,
                  fontWeight: '600',
                  alignSelf: 'flex-start',
                  color: colors['text-primary']
                }, actionButtonTextStyle],
                className: actionButtonTextClassName,
                children: action.label
              })
            }) : action || undefined, (0, _types.isToastAction)(cancel) ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Pressable, {
              onPress: () => {
                cancel.onClick();
                onDismiss?.(id);
              },
              className: cancelButtonClassName,
              style: [unstyled ? undefined : {
                flexGrow: 0
              }, cancelButtonStyle],
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
                numberOfLines: 1,
                style: [unstyled ? undefined : {
                  fontSize: 14,
                  lineHeight: 20,
                  fontWeight: '600',
                  alignSelf: 'flex-start',
                  color: colors['text-secondary']
                }, cancelButtonTextStyle],
                className: cancelButtonTextClassName,
                children: cancel.label
              })
            }) : cancel || undefined]
          })]
        }), closeButton && dismissible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Pressable, {
          onPress: () => onDismiss?.(id),
          hitSlop: 10,
          style: [stylesCtx.closeButton, styles?.closeButton],
          className: cn(classNamesCtx.closeButton, classNames?.closeButton),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.X, {
            size: 20,
            color: colors['text-secondary'],
            style: [stylesCtx.closeButtonIcon, styles?.closeButtonIcon],
            className: cn(classNamesCtx.closeButtonIcon, classNames?.closeButtonIcon)
          })
        }) : null]
      })
    })
  });
};
exports.Toast = Toast;
const ToastIcon = ({
  variant
}) => {
  const colors = (0, _useColors.useColors)();
  switch (variant) {
    case 'success':
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.CircleCheck, {
        size: 20,
        color: colors.success
      });
    case 'error':
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.CircleX, {
        size: 20,
        color: colors.error
      });
    case 'warning':
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.TriangleAlert, {
        size: 20,
        color: colors.warning
      });
    default:
    case 'info':
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.Info, {
        size: 20,
        color: colors.info
      });
  }
};
exports.ToastIcon = ToastIcon;
const elevationStyle = {
  shadowOpacity: 0.0015 * 4 + 0.1,
  shadowRadius: 3 * 4,
  shadowOffset: {
    height: 4,
    width: 0
  },
  elevation: 4
};
//# sourceMappingURL=toast.js.map