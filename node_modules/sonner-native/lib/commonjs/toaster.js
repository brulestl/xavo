"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getToastContext = exports.ToasterUI = exports.Toaster = void 0;
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeScreens = require("react-native-screens");
var _constants = require("./constants.js");
var _context = require("./context.js");
var _positioner = require("./positioner.js");
var _toast = require("./toast.js");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
let addToastHandler;
let dismissToastHandler;
const Toaster = props => {
  if (_reactNative.Platform.OS === 'ios') {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeScreens.FullWindowOverlay, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ToasterUI, {
        ...props
      })
    });
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(ToasterUI, {
    ...props
  });
};
exports.Toaster = Toaster;
const ToasterUI = ({
  duration = _constants.toastDefaultValues.duration,
  position = _constants.toastDefaultValues.position,
  offset = _constants.toastDefaultValues.offset,
  visibleToasts = _constants.toastDefaultValues.visibleToasts,
  swipToDismissDirection = _constants.toastDefaultValues.swipeToDismissDirection,
  closeButton,
  style,
  className,
  unstyled,
  invert,
  toastOptions,
  icons,
  pauseWhenPageIsHidden,
  cn,
  gap,
  ...props
}) => {
  const [toasts, setToasts] = React.useState([]);
  const toastsCounter = React.useRef(1);
  addToastHandler = React.useCallback(options => {
    const id = typeof options?.id === 'number' || options.id && options.id?.length > 0 ? options.id : toastsCounter.current++;
    const newToast = {
      ...options,
      id: options?.id ?? id,
      variant: options.variant ?? _constants.toastDefaultValues.variant
    };
    if (options?.id) {
      // we're updating
      setToasts(currentToasts => currentToasts.map(currentToast => {
        if (currentToast.id === options.id) {
          return {
            ...currentToast,
            ...newToast,
            duration: options.duration ?? duration,
            id: options.id
          };
        }
        return currentToast;
      }));
      return options.id;
    }
    setToasts(currentToasts => {
      const newToasts = [...currentToasts, newToast];
      if (newToasts.length > visibleToasts) {
        newToasts.shift();
      }
      return newToasts;
    });
    return id;
  }, [visibleToasts, duration]);
  const dismissToast = React.useCallback((id, origin) => {
    if (!id) {
      toasts.forEach(currentToast => {
        if (origin === 'onDismiss') {
          currentToast.onDismiss?.(currentToast.id);
        } else {
          currentToast.onAutoClose?.(currentToast.id);
        }
      });
      setToasts([]);
      toastsCounter.current = 1;
      return;
    }
    setToasts(currentToasts => currentToasts.filter(currentToast => currentToast.id !== id));
    const toastForCallback = toasts.find(currentToast => currentToast.id === id);
    if (origin === 'onDismiss') {
      toastForCallback?.onDismiss?.(id);
    } else {
      toastForCallback?.onAutoClose?.(id);
    }
    return id;
  }, [toasts]);
  dismissToastHandler = React.useCallback(id => {
    return dismissToast(id);
  }, [dismissToast]);
  const value = React.useMemo(() => ({
    duration: duration ?? _constants.toastDefaultValues.duration,
    position: position ?? _constants.toastDefaultValues.position,
    offset: offset ?? _constants.toastDefaultValues.offset,
    swipToDismissDirection: swipToDismissDirection ?? _constants.toastDefaultValues.swipeToDismissDirection,
    closeButton: closeButton ?? _constants.toastDefaultValues.closeButton,
    unstyled: unstyled ?? _constants.toastDefaultValues.unstyled,
    addToast: addToastHandler,
    invert: invert ?? _constants.toastDefaultValues.invert,
    styles: toastOptions?.styles ?? {},
    classNames: toastOptions?.classNames ?? {},
    icons: icons ?? {},
    pauseWhenPageIsHidden: pauseWhenPageIsHidden ?? _constants.toastDefaultValues.pauseWhenPageIsHidden,
    cn: cn ?? _constants.toastDefaultValues.cn,
    gap: gap ?? _constants.toastDefaultValues.gap
  }), [duration, position, offset, swipToDismissDirection, closeButton, unstyled, invert, toastOptions, icons, pauseWhenPageIsHidden, cn, gap]);
  const orderToastsFromPosition = React.useCallback(currentToasts => {
    return position === 'bottom-center' ? currentToasts : currentToasts.slice().reverse();
  }, [position]);
  const dynamicPositionedToasts = React.useMemo(() => {
    return toasts.filter(currentToast => currentToast.position && currentToast.position !== position);
  }, [position, toasts]);
  const nonDynamicToasts = React.useMemo(() => {
    return toasts.filter(currentToast => !dynamicPositionedToasts.includes(currentToast));
  }, [dynamicPositionedToasts, toasts]);
  const positionedNonDynamicToasts = React.useMemo(() => {
    return orderToastsFromPosition(nonDynamicToasts);
  }, [nonDynamicToasts, orderToastsFromPosition]);
  const positionedDynamicToasts = React.useMemo(() => {
    return orderToastsFromPosition(dynamicPositionedToasts);
  }, [dynamicPositionedToasts, orderToastsFromPosition]);
  const onDismiss = React.useCallback(id => {
    dismissToast(id, 'onDismiss');
  }, [dismissToast]);
  const onAutoClose = React.useCallback(id => {
    dismissToast(id, 'onAutoClose');
  }, [dismissToast]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_context.ToastContext.Provider, {
    value: value,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_positioner.Positioner, {
      className: className,
      style: style,
      position: position,
      children: positionedNonDynamicToasts.map(positionedToast => {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_toast.Toast, {
          ...positionedToast,
          onDismiss: onDismiss,
          onAutoClose: onAutoClose,
          ...props
        }, positionedToast.id);
      })
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_positioner.Positioner, {
      className: className,
      style: style,
      position: positionedDynamicToasts?.[0]?.position ?? _constants.toastDefaultValues.position,
      children: positionedDynamicToasts.map(positionedToast => {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_toast.Toast, {
          ...positionedToast,
          onDismiss: onDismiss,
          onAutoClose: onAutoClose,
          ...props
        }, positionedToast.id);
      })
    })]
  });
};
exports.ToasterUI = ToasterUI;
const getToastContext = () => {
  if (!addToastHandler || !dismissToastHandler) {
    throw new Error('ToastContext is not initialized');
  }
  return {
    addToast: addToastHandler,
    dismissToast: dismissToastHandler
  };
};
exports.getToastContext = getToastContext;
//# sourceMappingURL=toaster.js.map